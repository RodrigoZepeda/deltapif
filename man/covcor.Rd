% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03-covariances.R
\name{covcor}
\alias{covcor}
\alias{cov}
\alias{cov_pif_list_class}
\alias{var}
\alias{sd}
\alias{cor}
\title{Covariance matrix, correlation matrix, variance and standard deviation
for potential impact fractions}
\usage{
cov(
  x,
  ...,
  sigma_p = NULL,
  sigma_beta = NULL,
  independent_p = "guess",
  independent_beta = "guess",
  quiet = FALSE
)

cov_pif_list_class(
  pif1,
  pif2,
  sigma_p = NULL,
  sigma_beta = NULL,
  independent_p = "guess",
  independent_beta = "guess",
  quiet = FALSE
)

var(x, ...)

sd(x, ...)

cor(
  x,
  ...,
  sigma_p = NULL,
  sigma_beta = NULL,
  independent_p = "guess",
  independent_beta = "guess",
  quiet = FALSE
)
}
\arguments{
\item{x}{A potential impact fraction}

\item{...}{Multiple additional potential impact fraction objects
separated by commas.}

\item{sigma_p}{Covariance matrix for the prevalences in all \code{pif1} and
the ones included in \code{...}.}

\item{sigma_beta}{Covariance matrix for the parameter \code{beta} in all \code{pif1}
and the ones included in \code{...}.}

\item{independent_p}{If all the pifs share the same prevalence data. Either
\code{TRUE}, \code{FALSE}, \code{guess} (default) or a matrix. If a matrix is given then
\code{independent_p[i,j] = 1} if the i-th and j-th pifs share the same prevalence data
\code{independent_p[i,j] = 0} if the i-th and j-th pifs don't share the same prevalence data.}

\item{independent_beta}{If all the pifs share the same \code{beta} parameter. Either
\code{TRUE}, \code{FALSE} or \code{guess} (default) or a matrix. If a matrix is given then
\code{independent_beta[i,j] = 1} if the i-th and j-th pifs share the same relative risk parameters
\code{independent_beta[i,j] = 0} if the i-th and j-th pifs don't share the same relative risk parameters.}
}
\description{
Computes the covariance (\code{cov}) or correlation (\code{cor}) for multiple
potential impact fractions and the variance \code{var} and standard deviation
\code{sd}for a potential impact fraction.

Recursively obtains the covariance matrix of a \code{pif_list_class}
}
\examples{
# Get the approximate variance of a pif object
my_pif <- pif(p = 0.5, p_cft = 0.25, beta = 1.3, sigma_p = 0.1, sigma_beta = 0.2)
var(my_pif)

# This is the same as covariance with just 1 pIF
cov(my_pif)

# Calculate the covariance between 3 fractions with shared relative risk
beta <- 0.3
sigma_beta <- 0.1
pif1 <- pif(0.5, 0.2, beta, sigma_p = 0.5 * (1 - 0.5) / 100, sigma_beta = sigma_beta)
pif2 <- pif(0.3, 0.1, beta, sigma_p = 0.3 * (1 - 0.3) / 100, sigma_beta = sigma_beta)
pif3 <- pif(0.7, 0.3, beta, sigma_p = 0.7 * (1 - 0.7) / 100, sigma_beta = sigma_beta)
cov(pif1, pif2, pif3, independent_beta = FALSE)

# The covariance between a pif and itself only has the variance as entries
cov(pif1, pif1, independent_beta = FALSE, independent_p = FALSE)

# Or if there is a covariance structure between different betas you can specify with
# sigma_beta in the covariance
betas <- c(1.3, 1.2, 1.27)

# Covariance among all betas
sigma_beta <- matrix(c(
  1.0000000, -0.12123053, 0.35429369,
  -0.1212305, 1.00000000, -0.04266409,
  0.3542937, -0.04266409, 1.00000000
), byrow = TRUE, ncol = 3)
pif1 <- pif(0.5, 0.2, betas[1], sigma_p = 0.5 * (1 - 0.5) / 100, sigma_beta = sigma_beta[1, 1])
pif2 <- pif(0.3, 0.1, betas[2], sigma_p = 0.3 * (1 - 0.3) / 100, sigma_beta = sigma_beta[2, 2])
pif3 <- pif(0.3, 0.1, betas[3], sigma_p = 0.3 * (1 - 0.3) / 100, sigma_beta = sigma_beta[3, 3])
cov(pif1, pif2, pif3, sigma_beta = sigma_beta)

# Compute the correlation
cov(pif1, pif2, pif_list(pif1, pif3), sigma_beta = sigma_beta, quiet = TRUE)
}
\keyword{internal}
